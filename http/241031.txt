PUT, PATCH, POST
=> PUT은 덮어쓰기 되고 없으면 새로 만들어짐
=> PATCH는 이미 있는 데이터에서 한 컬럼만 값을 바꾸고 싶을 때 쓴다.
=> 새로 등록하는 데이터(회원)이거나 애매하면 POST를 사용하자

회원 관리 시스템
POST - 신규 자원 등록 특징

- 클라이언트는 등록될 리소스의 URI를 모른다.
	회원 등록 /members -> POST
	POST /members
- 서버가 새로 등록된 리소스 URI를 생성한다.
	HTTP/1.1 201 Created
	Location: /members/100

-컬렉션
=> 서버가 관리하는 리소스 디렉토리
=> 서버가 리소스의 URI를 생성하고 관리
=> 여기서 컬렉션은 /members

=======================

파일 관리 시스템
PUT - 신규 자원 등록 특징

- 클라이언트가 리소스 URI를 알고 있어야 한다
	파일 등록 /files/{filename} -> PUT
	PUT /files/star.jpg

- 클라이언트가 직접 리소스의 URI를 지정한다.

- 스토어
	- 클라이언트가 관리하는 리소스 저장소
	- 클라이언트가 리소스의 URI를 알고 관리
	- 여기서 스토어는 /files

POST 방식을 훨씬 많이 쓴다.


============================

상태코드
1xx (Informational): 요청이 수신되어 처리중
2xx (Successful): 요청 정상 처리
	201 Created
	202 Accepted : 요청이 접수되었으나 처리가 완료되지 않았음
		=> 배치 처리 같은 곳에서 사용한다 ( 요청 접수 후 1 시간 뒤에 배치 프로세스가 요청을 처리함)
	204 No Content
3xx (Redirection): 요청을 완료하려면 추가 행동이 필요
4xx (Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함

=============================

리다이렉션 이해
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
	ex) /members -> users
	ex) /event -> /new-event
- 일시 리다이렉션 : 일시적인 변경
	- 주문 완료 후 주문 내역 화면으로 이동
	- PRG (Post/Redirect/Get)
- 특수 리다이렉션
	- 결과 대신 캐시를 사용


영구 리다이렉션
-301 Moved Permanently
	=> 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
-308 Permanent Redirect
	301과 기능은 같음
	리다이렉트시 요청 메서드와 본문 유지(처음 POST를 보내면 리다이렉트됨)

일시적인 리다이렉션
-302 Found
	리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
-307 Tempory Redirect
	리다이렉트시 요청 메서드와 본문 유지(요청 메서드를 변경하면 안된다. MUST NOT)
-303 See Other
	리다이렉트시 요청 메서드가 GET으로 변경

일시적인 리다이렉션-예시 PRG
-POST로 주문 후에 웹 브라우저를 새로고침하면?
-새로고침은 다시 요청
-중복 주문이 될 수 있다.
|
|
> post로 주문 후에 새로 고침으로 인한 중복 주문 방지
> post로 주문 후에(302가 와서) 주문 결과 화면을 get 메서드로 리다이렉트
> 새로고침해도 결화 화면을 get으로 조회
> 중복 주문 대신에 결과 화면만 get으로 다시 요청
|
|
>PRG 이후 리다이렉트
	=> URL이 이미 POST>GET으로 리다이렉트됨
	=> 새로고침해도 GET으로 결과 화면만 조회

=====================================

HTTP 헤더 1
(일반 헤더)

헤더의 용도
- HTTP 전송에 필요한 모든 부가정보
ex) 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트. 서버 정보, 캐시 관리 정보...
- 필요시 임의의 헤더 추가 가능


HTTP BODY
-message body - RFC7230(최신)

-메시지 본문을 통해 표현 데이터 전달
- 메시지 본문 = payload
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
  -- 데이터 유형(html, json), 데이터 길이, 압축 정보 등등
- 참고: 표현 헤더는 표현 메타데이터와 , 페이로드 메시지를 구분해야 하지만, 생략함


그래서 표현이 뭐징??

표현
- Content-Type: 표현 데이터의 형식
ex) 미디어 타입, 문자 인코딩 => text/html; charset=utf-8  / application/json  / image/png
- Content-Encoding: 표현 데이터의 압축 방식
ex) 표현 데이터를 압축하기 위해 사용, 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가, 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
=> gzip / deflate / identity
- Content-Language: 표현 데이터의 자연 언어
ex) 표현 데이터의 자연언어를 표현
=> ko / en  / en-US
- Content-Length: 표현 데이터의 길이
ex) 바이트 단위로 Transfer-Encoding(전송 코딩)을 사용하면 Content-Length를 사용하면 안됨
- 표현 헤더는 전송, 응답 둘다 사용

==================================
협상(콘텐츠 네고시에이션)
: 클라이언트가 선호하는 표현 요청
---- 클라이언트 쪽에서 이러이러한 것으로 선호하니까 서버가 주지 못할 수도 있지만 우선적으로 해당 조건으로 달라

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어
협상 헤더는 요청시에만 사용


협상과 우선순위1
Quality Values(q)
- 0~1, 클수록 높은 우선순위
- 생략하면 1
- Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
  --1. ko-kR;q=1 (q생략)
  --2. ko;q=0.9
  --3. en-US;q=0.8
  --4. en;q=0.7
  위와 같은 우선순위로 적용된다. q=1일 경우에는 ko-KR만 써서 q=1 생략가능


협상과 우선순위2
-구체적인 것이 우선된다.
ex) Accept: text/*, text/plain, text/plain;format=flowed,*/*
  --1. text/plain;format=flowed
  --2. text/plain
  --3. text/*
  --4. */*

협상과 우선순위3(여기까지 내려올 일은 별로 없다고 하지만 알아두자)
-구체적인 것을 기준으로 미디어 타입을 맞춘다.
ex) Accept:text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5
똑같이 적혀있는 조건이 있다면 1) q=? 이라고 조건이 정해져있다? 그러면 q 값으로 우선순위 설정 2)q=?같은 식이 없다? 그러면 q=1로 처리
*처리 되어있는 조건이 있었다면 해당하는 미디어 타입이 왔을 때 그 q 값으로 정해짐 ex) text/*;q=0.3에 text/plain이 포함되므로 0.3 순위


===============================
전송 방식
- 단순 전송 : Content-Length가 적혀있어서 한 번에 전송하고 한 번에 쭉 받을 수 있는 전송
- 압축 전송 : Content-Encoding에서 압축되어있는 (gzip) 것으로 전송되는 방식
- 분할 전송(Transfer-Encoding)
=> Transfer-Encoding: chunked 라고 되어있음 chunked는 덩어리, 덩어리를 쪼개서 보낸다.
=> ex) 아래와 같이 5바이트 잘라서 Hello 먼저 보내고 5바이트 잘라서 World 보내고 다 보냈으면 0찍히고 \r엔터 치고 끝낸다.
5
Hello ----- 여기까지 먼저 보내고
5
World ----- 그 다음에 여기까지 보내고
0
\r\n  ------ 다 보냈으면 끝낸다.

- 범위 전송 : Range: bytes=1001~2000 해당 범위만큼 전송하고 나머지도 해당하는 만큼 보내주는 식

===================================
일반정보
- From: 유저 에이전트의 이메일 정보
  => 일반적으로 잘 사용되지 않으며, 검색엔진 같은 곳에서 주로 사용된다. 요청에서 사용

- Referer: 이전 웹 페이지 주소
  => 현재 요청된 페이지의 이전 웹 페이지 주소로 A->B로 이동하는 경우 B를 요청할 때 Referer:A를 포함해서 요청한다. 즉, Referer을 사용해서 유입 경로 분석이 가능하며 요청에서 사용
      Referer은 Referrer의 오타임 근데 다 이미 그렇게 쓰고 있어서 못 바꾸고 땅땅땅 해버림

- User-Agent: 유저 에이전트 애플리케이션 정보
  Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36
  => 클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등), 통계 정보 낼 때 좋음(어느 브라우저에서 많이 쓰는 구나 등등), 어떤 종류의 브라우저에서 장애가 발생하는지 파악도 가능, 요청에서 사용

- Server: 요청을 처리하는 오리진 서버의 소프트웨어 정보
  - Server: Apache/2.2.22 (Debian)
  - server: nginx
  - 응답에서 사용

- Date: 메시지가 생성된 날짜
Mon, 28 Oct 2024 11:43:53 GMT
응답에서 사용(과거에는 요청에도 쓰였지만 최신 스펙에서는 응답에서만 사용되도록 바뀜)

==========================================
특별한 정보
Host: 요청한 호스트 정보(도메인)
  => 요청에서 사용, 필수, 하나의 서버가 여러 도메인을 처리해야 할 때, 하나의 IP주소에 여러 도메인이 적용되어 있을 때 Host가 없다면 어느 도메인으로 가야할지 모르기 떄문에 호스트는 무조건 있어야 한다.

Location: 페이지 리다이렉션
  => 웹브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)
  => 응답코드 3xx에서 설명
  => 201 (Created): Location 값은 요청에 의해 생성된 리소스 URI
  => 3xx (Redirection): Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴
Allow: 허용 가능한 HTTP 메서드
Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

==============================================
인증
- Authorization: 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate: 리소스 접근 시 필요한 인증 방법 정의
  => 401 Unauthorized 응답과 함께 사용
  => 인증 정보를 만들어서 함께 넣어줘야 한다.

================================================
쿠키
-set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
-Cookie: 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
ex) 로그인
웹 브라우저가 user=홍길동이라는 것으로 login 페이지에 접속한다면 서버에서는 set-Cookie를 통해서 user=홍길동 이라는 값을 쿠키 저장소(웹 브라우저에 존재)에 저장을 한다.
그래서 로그인 후 welcome 페이지에 접속한다면 일단 서버에서 쿠키 저장소를 뒤지고 그 안에서 user의 값을 가지고 와서 안녕하세요 홍길동님을 보낸다.

- 사용처: 사용자 로그인 세션 관리/ 광고 정보 트래킹
- 쿠키 정보는 항상 서버에 전송됨: 네트워크 트래픽 추가 유발/ 최소한의 정보만 사용(세션id, 인증 토큰)
  /서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹 스토리지(localStorage, sessionStorage)참고
- 주의!!! : 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)

쿠키-생명주기
- Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT
  => 만료일이 되면 쿠키 삭제
- Set-Cookie: max-age=3600 (3600초)
  => 0이나 음수를 지정하면 쿠키 삭제
- 세션 쿠키: 만료 날짜를 생략하면 브라우저 종료시까지만 유지
- 영속 쿠키: 만료 날짜를 입력하면 해당 날짜까지 유지

쿠키-도메인
ex) domain=example.org
- 명시: 명시한 문서 기준 도메인 + 서브 도메인 포함
  => domain=example.org를 지정해서 쿠키 생성했다면
      dev.example.org에서도 쿠키 접근 가능
- 명시하지 않았다면: 현재 문서 기준 도메인만 적용
  => example.org에서 쿠키를 생성하고  domain 지정을 생략했다면
      example.org에서만 쿠키 접근이 가능하고
      dev.example.org에서는 쿠키 미접근

쿠키-경로
ex) path=/home
이 경로를 포함한 하위 경로 페이지만 쿠키 접근이 가능
일반적으로는 path=/ 루트로 지정해놓음
ex) path=/home 으로 지정했다면
  /home 가능
  /home/level1 가능
  /home/level1/level2 가능
  /hello 불가능

쿠키-보안
- Secure: 쿠키는 http, https를 구분하지 않고 전송/ Secure를 적용하면 https인 경우에만 전송
- HttpOnly: XSS 공격 방지/ 자바스크립트에서 접근 불가(document.cookie)/ HTTP 전송에만 사용
- SameSite: XSRF 공격 방지/ 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송

===========================================

캐시 적용
-캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
-비싼 네트워크 사용량을 줄일 수 있다.
-브라우저 로딩 속도가 매우 빠르다.
-빠른 사용자 경험

캐시 시간 초과
- 캐시 유효 시간이 초과해서 서버에 다시 요청하면 다음 두 가지 상황이 나타난다.
  1. 서버에서 기존 데이터를 변경함 (노란색 별에서 초록색 별로 바뀜)
  2. 서버에서 기존 데이터를 변경하지 않음(노란색 별 그대로)

- 캐시 만료후에도 서버에서 데이터를 변경하지 않았다면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다
  단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다
그래서 나온게 검증헤더

검증헤더
처음에 이미지를 줄 때 아에 Last-Modified 날짜를 포함해서 보내준다. 그래서 캐시를 저장할 때 유효 시간과 데이터 최종 수정일을 같이 보관하고 있다가
캐시 시간이 초과된 이후 다시 요청을 할 때 내가 캐시에 보관했던 데이터 최종 수정일을 서버에 같이 보낸다(if-modified-since) 그래서 서버에서는 이 날짜를 보고
판단해서 수정된게 없다고 판단되면 304 Not Modified를 보내주고 이때는 HTTP Body가 없으므로 서버의 부하가 줄어든다. 이후 기존에 저장되어 있는 응답 결과를 재사용하고 헤더 데이터를 갱신한다.
- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
  304 Not Modified + 헤더 메타 정보만 응답(바디x)
  클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
  클라이언트는 캐시에 저장되어 있는 데이터 재활용
  결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드
  매우 실용적인 해결책


검증헤더와 조건부 요청
-검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  => Last-Modified, ETag
- 조건부 요청 헤더
  => 검증 헤더로 조건에 따른 분기
  => if-Modified-Since: Last-Modified 사용
  => if-None-Match: ETag 사용
  => 조건이 만족하면 200 ok
  => 조건이 만족하지 않으면 304 Not Modified

ex) if-Modified-Since 이후에 데이터가 수정??
  1. 데이터 미변경 시
    => 304 Not Modified
  2. 데이터 변경 시
    => 200 Ok 로 다시 데이터 전송함

Last-Modified, if-Modified-Since 단점
- 1초 미만 단위로 캐시 조정 불가능
- 날짜 기반 로직 사용
- 데이터 수정해서 날짜 다르지만, 같은 데이터로 수정해서 데이터 결과가 똑같은 경우
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
  ex) 스페이스나 주석처럼 크게 영향이 없는 변경인 경우


ETag, if-None-Match
(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠
ex) ETag: "v1.0", ETag: "sdkjlkfjksldj54"
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
ex) ETag: "aaaaa" -> ETag: "bbbbb"
즉, ETag만 보내서 같으면 유지, 다르면 다시 받기
=> 캐시 제어 로직을 서버에서 완전히 관리/ 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 매커니즘을 모름)
ex) 서버는 배타 오픈 기간이 3일동안 파일이 변경되어도 ETag 동일하게 유지/ 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신

=======================================
Cache-Control
-Cache-Control: max-age 캐시 유효 시간, 초단위
-Cache-Control: no-cache 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
-Cache-Control: no-store 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 최대한 빨리 삭제)

프록시 캐시
로컬에서 원서버 접근하기 전에 중간에 프록시 캐시서버가 있음 여기에서 확인하고 있으면 주니까 빠름.

cache-control: public 응답이 public 캐시에 저장되어도 됨
cache-control: private 응답이 해당 사용자만을 위한 것임. private 캐시에 저장해야 함(기본값)
cache-control: s-message 프록시 캐시에만 적용되는 max-age
Age: 60 (HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)


확실한 캐시 무효화 응답이 되려면 아래와 같이 다 넣어줘야 함
=> Cache-Control: no-cache, no-store, must-revalidate
    Pragma: no-cache(혹시 모를 호환성으로 인해)